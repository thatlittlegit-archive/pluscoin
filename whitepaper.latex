\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{mathtools}

\title{The Pluscoin Cryptocurrency}
\author{thatlittlegit}
\date{}

\begin{document}
\pagenumbering{roman}
\maketitle
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction.}
Pluscoin is a cryptocurrency intended to a) not be related to Bitcoin and b)
use modern methods for consensus and mining. It uses Proof of Activity\footnote{
	See \url{https://bitcointalk.org/?topic=102355}}
by Charlie Lee as a consensus model. This document states the requirements for
an implementation of Pluscoin.

\paragraph{The example implementation.} The example implementation is written
in GNU Guile\footnote{See \url{https://gnu.org/software/guile}}, so as to be
cross-platform, clean and runnable on libre systems. However, an optimal
implementation should be written in a faster language, perhaps Rust. A software
claiming to be Pluscoin shall be fully compatible with the example
implementation.

\section{Choosing the Lucky Stakeholder.}
The lucky stakeholder shall be chosen {\it{individually}} by each user, and the
user in question {\it{should}} calculate itself. If the stakeholder finds it is
due to sign the block, it shall sign the block with a RSA-2048 key generated
with the SHA-512 hash of the previous $x$ equations and the ASCII85 of the
stakeholder's private key\footnote{Which should not be released; in fact, only
the signed block should be distributed. If someone else need know the SHA hash,
they can calculate it themselves.} as the passphrase, where the following is
calculated for $x$ (with $b=\textrm{number of transactions}$):

\begin{equation}
	x = 100 + \lfloor \dfrac{b}{256} \rceil
\end{equation}

Assume we are on the 364$^{th}$ transaction. We would find $x = 100 + \lfloor
1.421875 \rceil = 100 + 1 = 101$, thus the SHA-512 of the 101 previous
transactions ought to be calculated.

\paragraph{The generation of the SHA-512 hashes.} The hashes shall be generated
by finding the oldest block in the chain that shall be calculated, calculating
it, and moving to the next, calculating it {\it{and}} the previous one. This
process shall be repeated until complete. The individual hashes themselves
shall be generated by a JSON2-serialized version of the struct.

\paragraph{Calculating the Lucky Stakeholder from the hash.} The
lucky stakeholder shall be chosen by finding the $x$ hashes and finding the
closest known account. This shall be done by checking if a account exists with
the hash\footnote{Which is very rare, and indeed shouldn't happen.}. If so, the
stakeholder is due to sign it. If not, the last letter is ignored (equivalent
to a \verb|.| in regular expressions) and the process is repeated, with the
block signed or another letter ignored, {\it{et cetra}}. If there are multiple
matches, the one with the most currency on the main chain is to be winner.

\paragraph{Signing the block.} First, shall the signer deem the block invalid
they shall mark the infringing transaction as 'invalid'. Following that, the
block is to be signed with, as described above, a RSA-2048 key generated from
the $x$ hashes and the ASCII85 of the
stakeholder's private key. The public key shall be packaged with the block, and
the block shall be hashed with either SHA-512 or SHA3-512. This shall be
identified with a symbol at the beginning of the hash: 0b00110000 (\verb|0|) or
0b00110001 (\verb|1|). Should more hashes be necessary, they shall be denoted by
0b00110000 (\verb|Ã€|) + $y$, where
$y = \textrm{number of additional hashes} - 1$.\footnote{Note that no additional
hashes should be added unless agreed with by over 50\% of the blockchain;
signing with unknown hashes will be considered invalid and a re-selection using
the stakeholder-choosing function above deemed necessary.} The hash from the
block shall then be packaged with the block via a struct (HashedBlock), and the
hash signed with the key.

\paragraph{Rewards for signing.} The user who signs a block shall recieve $c$
currency, where $c$ can be calculated as (with
$b = \textrm{number of transactions}$):
\begin{equation}
	c = \dfrac{b^2}{(b \textrm{ mod } 128) + 256}
\end{equation}
As such, with 100 transactions the user would recieve $c = \frac{b^2}{100 + 256}
= \frac{b^2}{356} = \frac{10000}{356} \approx 28.089$ currency. This currency
shall not be represented in a 'transaction'; rather, it should be implied when
a block is signed by a user they gain $c$ in their wallet.

\section{Peer-To-Peer Network and Transactions.}
A Peer-to-Peer (hereforth referred to as P2P) network is necessary for a
decenteralized currency. As such, Pluscoin uses the Kademlia hash-table to
manage blocks.

\paragraph{Creating a Transaction.} To create a transaction, the sender (Alice)
broadcasts to all nodes she knows that she has a transaction to the recipient
(Bob), in the form of a SignedTransaction. This SignedTransaction consists of
the Transaction with a 64-bit double-precision floating-point number cut to 16
decimal digits, as well as a SHA3-512 hash of the transaction. This hash is
then signed with Alice's private key, and distributed. The nodes, including
Alice and Bob, then add the transaction to the block. They all (including Alice
and Bob!) find who must sign it; and standard procedure ensues.

\paragraph{Special Transactions.} Transactions to 
{\texttt{00112233445566778899AABBCCDDEE\-FF00112233445566778899AABBCCDDEE00}}
are considered 'special': these are for creation of additional wallets, etc.
Sending $0$ currency to this address with a description of one of the following
is then interpreted as the corresponding action:

\begin{itemize}
	\item \verb|@<user>*<pubkey>|: Creates a new user \verb|<user>| with
		a wallet public-key of \verb|<pubkey>|, which is a ASCII85\-
		encoded version of her public key. Her wallet hash is to
		be the SHA3-512 hash of \verb|<pubkey>|. \verb|<user>| may be
		at most 3 characters long, and is {\it{not intended to be
		unique!}}.
\end{itemize}
\begin{center}
	{\it{As of yet, no further special transactions exist.}}
\end{center}

\paragraph{Propagating a Signed Block.} A signed block is to be sent to all
nodes in the K-bucket. All nodes recieving this block are then to validate
the internal transactions. If the internal transactions are incorrect and not
marked invalid, the block is to be {\it{discarded}} and {\it{not propagated!}}
However, if it is deemed valid the block is to be propagated, and this process
repeated. A node should also detect if the transaction is inside of its
K-bucket, and if so propagate to another K-bucket. If it came from another
K-bucket, it should be propagated to the same K-bucket, {\it{et cetra}}.

\paragraph{Verifying a Transaction.} A transaction is to be verified by first
checking if the chain identifier (chainid) is equal to what is
expected\footnote{$0$ shall be used on the main network.}. It shall also be
checked that the wallet exists, is
{\texttt{00112233445566778899AABBCCDDEE\-FF00112233445566778899AABBCCDDEE00}}
or is
{\texttt{000000000000000000000000000000\-0000000000000000000000000000000000}}.
This can be done by looking in the blockchain to see if a special transaction
as described above happened with the hash\footnote{It may be useful to cache
this, thus preventing unnecessary hash computing.}. If the wallet does not
exist, the transaction shall be marked invalid. It then shall be checked if the
value of the transaction is 0 currency. If it is, and it is not to
a special address, then the transaction is invalid. It then shall be checked
that the wallet has enough money to send. If it does not, it shall be invalid.
This can be found by searching backward through the blockchain\footnote{Once
again, this may be useful to cache.}$^,$\footnote{If/when Pluscoin is used
daily, and thousands of transactions occur per day, it may be useful to
stakeholders to periodically move their funds to and from a temporary account.
This would reduce the amount of entries {\it{necessary}} to search, thus
increasing the speed of their transactions.}. It shall then finally be tested
if the transaction's signed hash matches the public key in the account-creation
transaction. If not, it is invalid. Otherwise, it is valid and can be
propagated as such.


\paragraph{When blocks shall be made.} Blocks shall be made when either:
\begin{enumerate}
	\item[a)] eleven-thousand-seven-hundred-eighty-one transactions have
		occurred, or
	\item[b)] a single minute (60 000 milliseconds, within 100 milliseconds)
		has passed since the previous transaction.
\end{enumerate}
Shall either of these conditions be met, a new Block shall be generated. It is
expected all clients on the network should do this at the same time, generating
the same block.

\paragraph{Some notes on Consensus.} Unlike most Proof-Of-
{\underline{\ \ \ \ \ \ \ \ \ \ }} algorithms, Pluscoin users are intended to
share an implied blockchain. If a block is found invalid, the block is not
stored or distributed. The client mistakenly signing the block is considered
out-of-date. However, should a transaction be found to be based on an erronous
block it should be attempted to fix it. As an example (with shorter hashes),
assume Alice sends Bob a transaction based on \verb|a6f2b69d|. The problem is
that \verb|a6f2b69d| was invalid, with no plausable fix, and was thus
discarded. However, Bob notes the transaction is valid, and as such prescribes
it to his latest, \verb|f3a8baaf|. Alice's chain is here considered incorrect.
It may be advisable to send a GenericMessage to Alice, saying she ought to
resync, however seeing as invalid-blockchain issues should never happen anyway
such a pleasantry is unnecessary.\footnote{To prevent differing implementations
on the matter, a GenericMessage containing "{\texttt{REBUILD\_CHAIN}}" shall be
considered a note to update the chain. However, some implementations may ignore
this. It is still acceptable to claim to be Pluscoin without implementing this.}

\paragraph{Syncing the Blockchain.} The blockchain is to be synced (rebuilt) by
contacting the 3 nearest K-Buckets and sending a GenericMessage containing
"{\texttt{BLOCKHASH}}", which shall be responded to by sending the hash of the
{\it{previous transaction}}, not the $x$ transactions before. Another
GenericMessage "{\texttt{REQUEST\_CHAIN {\it{p}}}" shall then be sent to
$\frac{1}{3}$ of the nearest 4 K-buckets, which shall respond with as up to
65536 transactions starting at number $p$ via a Brotli-compressed JSON array in
the form of a \verb|Block[65536]|. The response shall be at most $2^{32}$ bytes
in length. The uncompressed` shall also be RSA-signed with the private key of
the sender.

\section{Classes \& Structs.}
\paragraph{Some notes.} The classes and structs defined herein should be used
vertabim. It is entirely possible, indeed recommendable, to change these to fit
the standards of the programming language, however when sent should reflect
these. A client is to ignore invalid structs. All hashes are to be made from
a JSON2-serialized version of the struct.

\paragraph{Communication of Structs.} A struct is to be broadcasted via a
object in JavaScript Object Notation (JSON) 5
\footnote{See \url{json5.org}.}$^,$\footnote{Note this is identical to the
object notation in EMCA-262 version 6 and higher.} corresponding to the struct.
Note that structs over 10 megabytes ($10 \times 1024^2$ bytes) may be ignored
(and if necessary, the connections cut prematurely). Structs are to be
differentiated by the \verb|__STRUCT__|  byte.

\paragraph{Shorthand.} The names of the fields may be shortened to a
shorthand name to reduce necessary bandwidth. In addition,
Brotli\footnote{See \url{https://github.com/google/brotli} and IETF RFC 7932.}
compression may be used. All clients must support these, and accept structs not
implementing these modifications.

\begin{center}
	{\bf{* * *}}
\end{center}

\paragraph{Transaction}
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|0|.
	\item \verb|sender| (\verb|Se|, string[320]): The sender's public key
		in ASCII85.
	\item \verb|recipient| (\verb|Re|, string[64]): The SHA3-512 hash of
		the recipient's private key.
	\item \verb|currency| (\verb|Cu|, double): The currency to send, cut to
		16 decimal points.
	\item \verb|message| (\verb|Me|, string[256]): The message accompanying
		the transaction in UTF-8 format.
\end{itemize}

\paragraph{HashedTransaction} {\it{extends}} HashedObject
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|10|.
	\item \verb|transaction| (\verb|Tr|, Transaction): The transaction.
\end{itemize}

\paragraph{Block} (a block can be at most 8 megabytes ($8 \times 1024^2$ bytes))
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|2|.
	\item \verb|transactions| (\verb|Tr|,
		Transaction[11781\footnote{$\dfrac{8 \times 1024^2}{712}$. 712
		was found by adding the byte counts in Transaction together in
		Xcalc.}]): The transactions in the block.
	\item \verb|era| (\verb|Er|, int): The number of times $2^{32}$ goes
		into the number of seconds since the UNIX epoch
		($\frac{s}{2^{32}}$, where $s = \textrm{seconds since
		UNIX epoch}$.)
	\item \verb|timestamp| (\verb|Ti|, long): The number of milliseconds
		since the previous time \verb|era| changed\footnote{This can be
		found by finding $t$ where $t \approx s \textrm{ mod } 2^{32}$,
		where $s = \textrm{seconds since UNIX epoch}$.} Must be accurate
		between 2000 milliseconds\footnote{Which the prior footnote
		can approximate within.}.
\end{itemize}

\paragraph{HashedBlock} {\it{extends}} HashedObject
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|11|.
	\item \verb|block| (\verb|Bl|, Block): The hashed block.
\end{itemize}

\paragraph{HashedObject} (shall never be distributed)
\begin{itemize}
	\item \verb|__VERSION__| (\verb|_V|, byte): Always \verb|0|\footnote{
			This is intended for future versions, which may use
			elliptic-curve cryptography. 0 will always indicate
			RSA. (RSA may also be phased out, and as such be
			denied; however, this should not be fretted about
			now.)}.
	\item \verb|signature| (\verb|Si|, string[320]): The signed hash using
		the OAEP padding scheme\footnote{See IETF RFC 2437.} and RSA
		encryption.
\end{itemize}

\paragraph{GenericMessage} (shall never be broadcasted; broadcasted messages
shall be discarded)
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|9|.
	\item \verb|message| (\verb|Me|, string[1024]): The message sent.
\end{itemize}

\section{Final Remarks.}
Pluscoin was built as a cryptocurrency that was not based on Bitcoin, Litecoin,
Ethereum, etc. I also wanted to make sure that the number of hashes that are
necessary to generate was a minimum.

In the first paragraph, you may recall:

\begin{quote}
	It uses Proof of Activity$^1$ by Charlie Lee as a consensus model.
\end{quote}

This was true when I began writing the paper. However, as Pluscoin evolved, it
grew away from PoA. It, in my opinion, shows how Pluscoin evolved.

Farewell, reader. I hope Pluscoin... y'know, works. And can't be counterfeited.

\begin{flushright}
	thatlittlegit \\
	thatlittlegit@protonmail.com \\
	thatlittlegit.tk
\end{flushright}

\begin{center}
	{\textsc{This document is for Pluscoin 1.0-beta0.}}
\end{center}
\end{document}
