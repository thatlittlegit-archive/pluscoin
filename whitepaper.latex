\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{mathtools}

\title{The Pluscoin Cryptocurrency}
\author{thatlittlegit}
\date{}

\begin{document}
\pagenumbering{roman}
\maketitle
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction.}
Pluscoin is a cryptocurrency intended to a) not be related to Bitcoin and b)
use modern methods for consensus and mining. It uses Proof of Activity\footnote{
	See \url{https://bitcointalk.org/?topic=102355}}
by Charlie Lee as a consensus model. This document states the requirements for
an implementation of Pluscoin.

\paragraph{The example implementation.} The example implementation is written
in GNU Guile\footnote{See \url{https://gnu.org/software/guile}}, so as to be
cross-platform, clean and runnable on libre systems. However, an optimal
implementation should be written in a faster language, perhaps Rust. A software
claiming to be Pluscoin shall be fully compatible with the example
implementation.

\section{Choosing the Lucky Stakeholder.}
The lucky stakeholder shall be chosen {\it{individually}} by each user, and the
user in question {\it{should}} calculate itself. We can find the user by
finding the SHA3-512 hash of the previous $x$ transactions (with
$b=\textrm{number of transactions}$):

\begin{equation}
	x = 8 + \lfloor \dfrac{b}{256} \rceil
\end{equation}

Assume we are on the 364$^{th}$ transaction. We would find $x = 8 + \lfloor
1.421875 \rceil = 8 + 1 = 9$, thus the SHA3-512 of the 9 previous
transactions ought to be calculated.

\paragraph{The generation of the SHA3-512 hashes.} The hashes shall be generated
by finding the oldest block in the chain that shall be calculated, calculating
it, and moving to the next, calculating it {\it{and}} the previous one. This
process shall be repeated until complete. The individual hashes themselves
shall be generated by a JSON2-serialized version of the struct with no
shorthand.

\paragraph{Calculating the Lucky Stakeholder from the hash.} The
lucky stakeholder shall be chosen by finding the $x$ hashes and finding the
closest known account. This shall be done by checking if a account exists with
the hash\footnote{Which is very rare, and indeed shouldn't happen.}. If so, the
stakeholder recieves the reward. If not, the last letter is ignored (equivalent
to a \verb|.| in regular expressions) and the process is repeated until a user
is found. If there are multiple matches, the one with the most currency on the
is to be the lucky stakeholder.

\paragraph{Rewards.} The user who is found to be the stakeholder of a block
shall recieve $c$ currency, where $c$ can be calculated as (with
$b = \textrm{number of transactions}$):
\begin{equation}
	c = \dfrac{b^2}{(b \textrm{ mod } 128) + 256}
\end{equation}
As such, with 100 transactions the user would recieve $c = \frac{b^2}{100 + 256}
= \frac{b^2}{356} = \frac{10000}{356} \approx 28.089$ currency. This currency
shall not be represented in a 'transaction'; rather, it should be implied when
a block's stakeholder is the user they gain $c$ in their wallet.

\label{p2p}
\section{Peer-To-Peer Network and Transactions.}
A Peer-to-Peer (hereforth referred to as P2P) network is necessary for a
decenteralized currency. As such, Pluscoin uses the Kademlia hash-table to
manage blocks.

\paragraph{Creating a Transaction.} To create a transaction, the sender (Alice)
broadcasts to all nodes she knows that she has a transaction to the recipient
(Bob), in the form of a SignedTransaction. This SignedTransaction consists of
the Transaction with a 64-bit double-precision floating-point number cut to 16
decimal digits, as well as a SHA3-512 hash of the transaction. This hash is
then signed with Alice's private key, and distributed. The nodes, including
Alice and Bob, then add the transaction to their block. It is then
redistributed as stated in \S\ref{p2p}, \P\ref{prop}, except as a transaction
not a block.

\paragraph{Special Transactions.} Transactions to 
{\texttt{00112233445566778899AABBCCDDEE\-FF00112233445566778899AABBCCDDEE00}}
are considered 'special': these are for creation of additional wallets, etc.
They should be distributed, but {\it{not}} counted in the hash-generation
process. It may be advisable to represent these initially into Transactions,
and then transform them into internal objects with less memory which can be
reverted as necessary into Transactions. Sending $0$ currency to the address
with a description of one of the following is then interpreted as the
corresponding action:

\begin{itemize}
	\item \verb|@<user>*<pubkey>|: Creates a new user \verb|<user>| with
		a wallet public-key of \verb|<pubkey>|, which is a ASCII85\-
		encoded version of her public key. Her wallet hash is to
		be the SHA3-512 hash of \verb|<pubkey>|. \verb|<user>| may be
		at most 3 characters long, and is {\it{not intended to be
		unique!}}.
\end{itemize}
\begin{center}
	{\it{As of yet, no further special transactions exist.}}
\end{center}

\label{prop}
\paragraph{Propagating a Block.} A signed block is to be sent to all
nodes in the K-bucket. All nodes recieving this block are then to validate
the internal transactions. If the internal transactions are incorrect and not
marked invalid, the block is to be {\it{discarded}} and {\it{not propagated!}}
However, if it is deemed valid the block is to be propagated, and this process
repeated. A node should also detect if the transaction is inside of its
K-bucket, and if so propagate to another K-bucket. If it came from another
K-bucket, it should be propagated to the same K-bucket, {\it{et cetra}}.

\paragraph{Ordering of Transactions in a Block.} Transactions in a block are
to be ordered in the order they are recieved. Should multiple transactions be
sent in a \verb|Transaction[]|, they shall be inputted in the order in the
array. If multiple transactions arrive separately yet simultaniously they are
to be appended in the order that they are processed.\footnote{This would be
easiest in a single-threaded recieving area, where one comes in at a time.}

\paragraph{Verifying a Transaction.} A transaction is to be verified by first
checking if the chain identifier (chainid) is equal to what is
expected\footnote{$0$ shall be used on the main network.}. It shall also be
checked that the wallet exists, is
{\texttt{00112233445566778899AABBCCDDEE\-FF00112233445566778899AABBCCDDEE00}}
or is
{\texttt{000000000000000000000000000000\-0000000000000000000000000000000000}}.
This can be done by looking in the blockchain to see if a special transaction
as described above happened with the hash\footnote{It may be useful to cache
this, thus preventing unnecessary hash computing.}. If the wallet does not
exist, the transaction shall be marked invalid. It then shall be checked if the
value of the transaction is 0 currency. If it is, and it is not to
a special address, then the transaction is invalid. It then shall be checked
that the wallet has enough money to send. If it does not, it shall be invalid.
This can be found by searching backward through the blockchain\footnote{Once
again, this may be useful to cache.}$^,$\footnote{If/when Pluscoin is used
daily, and thousands of transactions occur per day, it may be useful to
stakeholders to periodically move their funds to and from a temporary account.
This would reduce the amount of entries {\it{necessary}} to search, thus
increasing the speed of their transactions.}. It shall then finally be tested
if the transaction's signed hash matches the public key in the account-creation
transaction. If not, it is invalid. Otherwise, it is valid and can be
propagated as such.


\paragraph{When blocks shall be made.} Blocks shall be made when either:
\begin{enumerate}
	\item[a)] eleven-thousand-seven-hundred-eighty-one transactions have
		occurred, or
	\item[b)] a single minute (60 000 milliseconds, within 100 milliseconds)
		has passed since the previous transaction.
\end{enumerate}
Shall either of these conditions be met, a new Block shall be generated. It is
expected all clients on the network should do this at the same time, generating
the same block.

\paragraph{Some notes on Consensus.} Pluscoin, unline other cryptocurrencies
such as Bitcoin and Ethereum, has no consensus model. Instead, it is a variety
of separate blockchains connected into one large network via Transactions,
which contain all necessary metadata. If a block is found invalid, the block
shan't be stored or distributed\footnote{Unless it is easily fixed; in which
case it is fixed and distributed. An example of a simple fix is if the
transaction is based on an invalid block yet is still valid if it is set on a
valid block.} and optionally the sender notified of the invalid block\footnote
{To prevent differing implementations, \texttt{REBUILD\_CHAIN} shall be used to
indicate a chain-rebuild may be necessary. This {\it{can}} be ignored, and
{\it{can}} be not sent by an implementation.}.

\paragraph{Syncing the Blockchain.} The blockchain is to be synced (rebuilt) by
contacting the 3 nearest K-Buckets and sending a GenericMessage containing
"{\texttt{BLOCKHASH}}", which shall be responded to by sending the hash of the
{\it{previous transaction}}, not the $x$ transactions before. Another
GenericMessage "{\texttt{REQUEST\_CHAIN {\it{p}}}" shall then be sent to
$\frac{1}{3}$ of the nearest 4 K-buckets, which shall respond with as up to
65536 transactions starting at number $p$ via a Brotli-compressed JSON array in
the form of a \verb|Block[65536]|. The response shall be at most $2^{32}$ bytes
in length. The uncompressed` shall also be RSA-signed with the private key of
the sender.

\section{Classes \& Structs.}
\paragraph{Some notes.} The classes and structs defined herein should be used
vertabim. It is entirely possible, indeed recommendable, to change these to fit
the standards of the programming language, however when sent should reflect
these. A client is to ignore invalid structs. All hashes are to be made from
a JSON2-serialized version of the struct.

\paragraph{Communication of Structs.} A struct is to be broadcasted via a
object in JavaScript Object Notation (JSON) 5
\footnote{See \url{json5.org}.}$^,$\footnote{Note this is identical to the
object notation in EMCA-262 version 6 and higher.} corresponding to the struct.
Note that structs over 10 megabytes ($10 \times 1024^2$ bytes) may be ignored
(and if necessary, the connections cut prematurely). Structs are to be
differentiated by the \verb|__STRUCT__|  byte.

\paragraph{Shorthand.} The names of the fields may be shortened to a
shorthand name to reduce necessary bandwidth. In addition,
Brotli\footnote{See \url{https://github.com/google/brotli} and IETF RFC 7932.}
compression may be used. All clients must support these, and accept structs not
implementing these modifications.

\paragraph{Format of Documentation.} The documentation is formatted as follows:
\begin{itemize}
	\item \verb|name| (\verb|shorthand|, type): description
\end{itemize}

\begin{center}
	{\bf{* * *}}
\end{center}

\paragraph{Transaction}
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|0|.
	\item \verb|sender| (\verb|Se|, string[320]): The sender's public key
		in ASCII85.
	\item \verb|recipient| (\verb|Re|, string[64]): The SHA3-512 hash of
		the recipient's private key.
	\item \verb|currency| (\verb|Cu|, double): The currency to send, cut to
		16 decimal points.
	\item \verb|message| (\verb|Me|, string[256]): The message accompanying
		the transaction in UTF-8 format.
\end{itemize}

\paragraph{HashedTransaction} {\it{extends}} HashedObject
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|10|.
	\item \verb|transaction| (\verb|Tr|, Transaction): The transaction.
\end{itemize}

\paragraph{Block} (a block can be at most 8 megabytes ($8 \times 1024^2$ bytes))
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|2|.
	\item \verb|transactions| (\verb|Tr|,
		Transaction[11781\footnote{$\dfrac{8 \times 1024^2}{712}$. 712
		was found by adding the byte counts in Transaction together in
		Xcalc.}]): The transactions in the block.
	\item \verb|era| (\verb|Er|, int): The number of times $2^{32}$ goes
		into the number of seconds since the UNIX epoch
		($\frac{s}{2^{32}}$, where $s = \textrm{seconds since
		UNIX epoch}$.)
	\item \verb|timestamp| (\verb|Ti|, long): The number of milliseconds
		since the previous time \verb|era| changed\footnote{This can be
		found by finding $t$ where $t \approx s \textrm{ mod } 2^{32}$,
		where $s = \textrm{seconds since UNIX epoch}$.} Must be accurate
		between 2000 milliseconds\footnote{Which the prior footnote
		can approximate within.}.
\end{itemize}

\paragraph{HashedBlock} {\it{extends}} HashedObject
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|11|.
	\item \verb|block| (\verb|Bl|, Block): The hashed block.
\end{itemize}

\paragraph{HashedObject} (shall never be distributed)
\begin{itemize}
	\item \verb|__VERSION__| (\verb|_V|, byte): Always \verb|0|\footnote{
			This is intended for future versions, which may use
			elliptic-curve cryptography. 0 will always indicate
			RSA. (RSA may also be phased out, and as such be
			denied; however, this should not be fretted about
			now.)}.
	\item \verb|signature| (\verb|Si|, string[320]): The signed hash using
		the OAEP padding scheme\footnote{See IETF RFC 2437.} and RSA
		encryption.
\end{itemize}

\paragraph{GenericMessage} (shall never be broadcasted; broadcasted messages
shall be discarded)
\begin{itemize}
	\item \verb|__STRUCT__| (\verb|__|, byte): Always \verb|9|.
	\item \verb|message| (\verb|Me|, string[1024]): The message sent.
\end{itemize}

\section{Final Remarks.}
Pluscoin was built as a cryptocurrency that was not based on Bitcoin, Litecoin,
Ethereum, etc. I also wanted to make sure that the number of hashes that are
necessary to generate was a minimum.

In the first paragraph, you may recall:

\begin{quote}
	It uses Proof of Activity$^1$ by Charlie Lee as a consensus model.
\end{quote}

This was true when I began writing the paper. However, as Pluscoin evolved, it
grew away from PoA. It, in my opinion, shows how Pluscoin evolved.

Farewell, reader. I hope Pluscoin... y'know, works. And can't be counterfeited.

\begin{flushright}
	thatlittlegit \\
	thatlittlegit@protonmail.com \\
	thatlittlegit.tk
\end{flushright}

\begin{center}
	{\textsc{This document is for Pluscoin 1.0-beta1.}}
\end{center}
\end{document}
